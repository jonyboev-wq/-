import React, { useEffect, useMemo, useRef, useState } from "react";
// NOTE: This single-file React app renders an interactive topo editor.
// Paste into a new project (Vite/Next/CRA) or run directly in the ChatGPT canvas preview.
// No backend required. One dependency used: d3-contour (available in this environment).
import { contours as d3Contours } from "d3-contour";

// ---------- Utilities ----------
function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function niceMin(val, step) { return Math.floor(val / step) * step; }
function niceMax(val, step) { return Math.ceil(val / step) * step; }
function linScale(domainMin, domainMax, rangeMin, rangeMax) {
  const d = domainMax - domainMin;
  const r = rangeMax - rangeMin;
  return (v) => rangeMin + ((v - domainMin) * r) / (d === 0 ? 1 : d);
}
function formatNum(n) {
  if (Math.abs(n) >= 1000 || Math.abs(n) < 0.01) return n.toExponential(2);
  return Number.isInteger(n) ? String(n) : n.toFixed(2);
}

// Parse CSV / TSV / whitespace with optional header. Columns: x,y,z,(id?)
function parsePoints(text) {
  const lines = text
    .replace(/\r/g, "\n")
    .split(/\n+/)
    .map((s) => s.trim())
    .filter(Boolean);
  if (!lines.length) return [];
  let header = false;
  if (/x.*y.*z/i.test(lines[0])) header = true;
  const pts = [];
  for (let i = header ? 1 : 0; i < lines.length; i++) {
    const raw = lines[i]
      .split(/[;,\t ]+/)
      .map((s) => s.trim())
      .filter(Boolean);
    if (raw.length < 3) continue;
    let [x, y, z, id] = raw;
    const px = Number(x); const py = Number(y); const pz = Number(z);
    if (Number.isFinite(px) && Number.isFinite(py) && Number.isFinite(pz)) {
      pts.push({ id: id ?? String(i - (header ? 0 : -1)), x: px, y: py, z: pz });
    }
  }
  return pts;
}

function pointsToCSV(points) {
  const header = "x;y;z;id";
  const rows = points.map((p) => `${p.x};${p.y};${p.z};${p.id ?? ""}`);
  return [header, ...rows].join("\n");
}

// IDW interpolation on a regular grid (cols x rows) over [minX,maxX]x[minY,maxY]
function rasterizeIDW(points, { minX, maxX, minY, maxY }, cols, rows, power = 2, eps = 1e-6) {
  const values = new Float64Array(cols * rows);
  const w = cols;
  const h = rows;
  const dx = (maxX - minX) / (cols - 1);
  const dy = (maxY - minY) / (rows - 1);
  for (let j = 0; j < h; j++) {
    const y = minY + j * dy;
    for (let i = 0; i < w; i++) {
      const x = minX + i * dx;
      let num = 0;
      let den = 0;
      let exact = null;
      for (const p of points) {
        const ddx = x - p.x;
        const ddy = y - p.y;
        const dist2 = ddx * ddx + ddy * ddy;
        if (dist2 < eps * eps) { exact = p.z; break; }
        const wgt = 1 / Math.pow(dist2 + eps, power / 2);
        num += wgt * p.z;
        den += wgt;
      }
      values[j * w + i] = exact !== null ? exact : (den > 0 ? num / den : NaN);
    }
  }
  return { values, cols, rows };
}

// Build thresholds from min/max and step
function buildThresholds(minZ, maxZ, step) {
  if (!Number.isFinite(step) || step <= 0) return [];
  const start = niceMin(minZ, step);
  const end = niceMax(maxZ, step);
  const arr = [];
  for (let v = start; v <= end; v += step) arr.push(Number(v.toFixed(6)));
  return arr;
}

// Convert d3-contour polygon rings (grid coords) to SVG path in screen coords
function ringToPath(ring, gridToDomain, domainToScreen) {
  let d = "";
  for (let i = 0; i < ring.length; i++) {
    const [gx, gy] = ring[i];
    const { x, y } = gridToDomain(gx, gy);
    const { X, Y } = domainToScreen(x, y);
    d += (i === 0 ? `M ${X} ${Y}` : ` L ${X} ${Y}`);
  }
  return d + " Z";
}

// Example dataset (25 points ~5x5)
const EXAMPLE_CSV = `x;y;z;id
0;0;120;P1
50;0;121;P2
100;0;122;P3
150;0;122.5;P4
200;0;123;P5
0;50;119;P6
50;50;120.5;P7
100;50;121;P8
150;50;122;P9
200;50;123;P10
0;100;118;P11
50;100;119.5;P12
100;100;120.5;P13
150;100;121.5;P14
200;100;122.5;P15
0;150;117.5;P16
50;150;118.5;P17
100;150;119.5;P18
150;150;120.5;P19
200;150;121.5;P20
0;200;117;P21
50;200;117.5;P22
100;200;118.5;P23
150;200;119.5;P24
200;200;120;P25`;

// ---------- Main Component ----------
export default function TopoEditor() {
  const [csv, setCsv] = useState(EXAMPLE_CSV);
  const [points, setPoints] = useState(() => parsePoints(EXAMPLE_CSV));

  const [swapXY, setSwapXY] = useState(false);
  const [invertY, setInvertY] = useState(true); // screen Y downwards; invert to show geodetic Y up

  const [gridSpacing, setGridSpacing] = useState(25); // domain units
  const [showGrid, setShowGrid] = useState(true);
  const [showPoints, setShowPoints] = useState(true);
  const [showLabels, setShowLabels] = useState(true);

  const [cols, setCols] = useState(120);
  const [rows, setRows] = useState(120);
  const [idwPower, setIdwPower] = useState(2);

  const [contourStep, setContourStep] = useState(0.5);
  const [majorEvery, setMajorEvery] = useState(5); // every N minor steps

  const [width, setWidth] = useState(1000);
  const [height, setHeight] = useState(700);

  const svgRef = useRef(null);

  // Derived points with XY swap if needed
  const pts = useMemo(() => {
    return points.map((p) => (swapXY ? { ...p, x: p.y, y: p.x } : p));
  }, [points, swapXY]);

  // Domain extents (auto from points with padding)
  const domain = useMemo(() => {
    const xs = pts.map((p) => p.x);
    const ys = pts.map((p) => p.y);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    const padX = (maxX - minX) * 0.1 || 1;
    const padY = (maxY - minY) * 0.1 || 1;
    return { minX: minX - padX, maxX: maxX + padX, minY: minY - padY, maxY: maxY + padY };
  }, [pts]);

  // Z min/max
  const zstats = useMemo(() => {
    const zs = pts.map((p) => p.z);
    return { minZ: Math.min(...zs), maxZ: Math.max(...zs) };
  }, [pts]);

  // Build raster via IDW
  const raster = useMemo(() => {
    return rasterizeIDW(pts, domain, cols, rows, idwPower);
  }, [pts, domain, cols, rows, idwPower]);

  // Thresholds for contours
  const thresholds = useMemo(() => buildThresholds(zstats.minZ, zstats.maxZ, contourStep), [zstats, contourStep]);

  // d3-contours
  const d3c = useMemo(() => {
    if (!raster || !raster.values || !thresholds.length) return [];
    const gen = d3Contours().size([raster.cols, raster.rows]).smooth(true).thresholds(thresholds);
    return gen(raster.values);
  }, [raster, thresholds]);

  // Coordinate transforms
  const pad = 60; // screen padding for axes labels
  const X = linScale(domain.minX, domain.maxX, pad, width - pad);
  const Ybase = linScale(domain.minY, domain.maxY, height - pad, pad); // Y up in domain -> screen
  const Yinv = linScale(domain.minY, domain.maxY, pad, height - pad); // Y down if not inverted
  const toScreen = (x, y) => ({ X: X(x), Y: (invertY ? Ybase(y) : Yinv(y)) });

  // Grid helpers
  const gridLines = useMemo(() => {
    if (!showGrid || gridSpacing <= 0) return { xs: [], ys: [] };
    const xs = []; const ys = [];
    const x0 = niceMin(domain.minX, gridSpacing);
    const x1 = niceMax(domain.maxX, gridSpacing);
    const y0 = niceMin(domain.minY, gridSpacing);
    const y1 = niceMax(domain.maxY, gridSpacing);
    for (let x = x0; x <= x1 + 1e-9; x += gridSpacing) xs.push(x);
    for (let y = y0; y <= y1 + 1e-9; y += gridSpacing) ys.push(y);
    return { xs, ys };
  }, [domain, gridSpacing, showGrid]);

  // Grid->Domain mapping for d3 ring coords
  const gridToDomain = (gx, gy) => {
    const x = domain.minX + (gx / (cols - 1)) * (domain.maxX - domain.minX);
    const y = domain.minY + (gy / (rows - 1)) * (domain.maxY - domain.minY);
    return { x, y };
  };

  // Contour styling helpers
  const majorLevels = useMemo(() => {
    if (!thresholds.length) return new Set();
    const base = thresholds[0];
    const set = new Set();
    thresholds.forEach((t, i) => { if (i % majorEvery === 0) set.add(t); });
    // also ensure nice multiples of 1.0 are major when step < 1
    thresholds.forEach((t) => { if (Math.abs(t - Math.round(t)) < 1e-6) set.add(t); });
    return set;
  }, [thresholds, majorEvery]);

  // Add point by click
  const onSvgClick = (e) => {
    if (!svgRef.current) return;
    const pt = svgRef.current.createSVGPoint();
    pt.x = e.clientX; pt.y = e.clientY;
    const ctm = svgRef.current.getScreenCTM();
    if (!ctm) return;
    const inv = ctm.inverse();
    const sp = pt.matrixTransform(inv);
    // invert screen->domain
    const x = domain.minX + ((sp.x - pad) / (width - 2 * pad)) * (domain.maxX - domain.minX);
    const yScreen = domain.minY + ((sp.y - pad) / (height - 2 * pad)) * (domain.maxY - domain.minY);
    const y = invertY ? (domain.maxY - (yScreen - domain.minY)) : yScreen; // adjust inversion
    const zStr = prompt("Высота точки (z):", "0");
    if (zStr === null) return;
    const z = Number(zStr);
    if (!Number.isFinite(z)) return alert("Нужно число.");
    const id = `P${points.length + 1}`;
    const newPoint = swapXY ? { id, x: y, y: x, z } : { id, x, y, z };
    const next = [...points, newPoint];
    setPoints(next);
    setCsv(pointsToCSV(next));
  };

  // Download SVG
  const downloadSVG = () => {
    const svg = svgRef.current;
    if (!svg) return;
    const serializer = new XMLSerializer();
    const source = serializer.serializeToString(svg);
    const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "topoplan.svg";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Upload CSV
  const onFile = (file) => {
    const reader = new FileReader();
    reader.onload = (ev) => {
      const text = String(ev.target?.result || "");
      setCsv(text);
      setPoints(parsePoints(text));
    };
    reader.readAsText(file);
  };

  // Clear points
  const clearPoints = () => {
    if (confirm("Удалить все точки?")) {
      setPoints([]);
      setCsv("x;y;z;id\n");
    }
  };

  // Fit canvas to window width in preview
  useEffect(() => {
    const onResize = () => {
      const maxW = Math.min(1200, Math.max(800, window.innerWidth - 420));
      setWidth(maxW);
      setHeight(Math.max(520, Math.min(900, Math.floor(maxW * 0.65))));
    };
    onResize();
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, []);

  const handleCsvChange = (t) => {
    setCsv(t);
    setPoints(parsePoints(t));
  };

  // UI
  return (
    <div className="w-full min-h-screen flex bg-slate-50 text-slate-800">
      {/* Sidebar */}
      <div className="w-[380px] shrink-0 border-r border-slate-200 bg-white p-4 space-y-5 sticky top-0 h-screen overflow-y-auto">
        <h1 className="text-2xl font-bold">ТопоРедактор</h1>
        <p className="text-sm text-slate-500">Вводите точки (x; y; z; id), настраивайте сетку и шаг горизонталей, скачайте SVG.</p>

        <section className="space-y-2">
          <div className="flex items-center justify-between">
            <label className="font-semibold">Данные точек</label>
            <div className="flex gap-2">
              <button className="px-2 py-1 text-xs rounded bg-slate-100 hover:bg-slate-200" onClick={()=>{handleCsvChange(EXAMPLE_CSV)}}>Пример</button>
              <label className="px-2 py-1 text-xs rounded bg-slate-100 hover:bg-slate-200 cursor-pointer">
                Импорт CSV
                <input type="file" accept=".csv,.txt" className="hidden" onChange={(e)=>{ const f = e.target.files?.[0]; if (f) onFile(f); }}/>
              </label>
              <button className="px-2 py-1 text-xs rounded bg-rose-50 text-rose-700 hover:bg-rose-100" onClick={clearPoints}>Очистить</button>
            </div>
          </div>
          <textarea
            value={csv}
            onChange={(e)=>handleCsvChange(e.target.value)}
            className="w-full h-40 font-mono text-xs p-2 border rounded focus:outline-none focus:ring"
            placeholder="x;y;z;id"
          />
          <div className="flex gap-3">
            <label className="flex items-center gap-2 text-sm"><input type="checkbox" checked={swapXY} onChange={(e)=>setSwapXY(e.target.checked)} /> Поменять X/Y</label>
            <label className="flex items-center gap-2 text-sm"><input type="checkbox" checked={invertY} onChange={(e)=>setInvertY(e.target.checked)} /> Ось Y вверх</label>
          </div>
        </section>

        <section className="space-y-2">
          <h2 className="font-semibold">Сетка и точки</h2>
          <div className="grid grid-cols-2 gap-2 items-center text-sm">
            <label>Шаг сетки</label>
            <input type="number" className="border rounded p-1" value={gridSpacing} onChange={(e)=>setGridSpacing(Number(e.target.value))} />
            <label>Показывать сетку</label>
            <input type="checkbox" checked={showGrid} onChange={(e)=>setShowGrid(e.target.checked)} />
            <label>Показывать точки</label>
            <input type="checkbox" checked={showPoints} onChange={(e)=>setShowPoints(e.target.checked)} />
            <label>Подписи точек</label>
            <input type="checkbox" checked={showLabels} onChange={(e)=>setShowLabels(e.target.checked)} />
          </div>
        </section>

        <section className="space-y-2">
          <h2 className="font-semibold">Интерполяция (IDW) и растр</h2>
          <div className="grid grid-cols-2 gap-2 items-center text-sm">
            <label>Столбцов (cols)</label>
            <input type="range" min={40} max={240} value={cols} onChange={(e)=>setCols(Number(e.target.value))} />
            <div className="text-right text-xs text-slate-500">{cols}</div>

            <label>Строк (rows)</label>
            <input type="range" min={40} max={240} value={rows} onChange={(e)=>setRows(Number(e.target.value))} />
            <div className="text-right text-xs text-slate-500">{rows}</div>

            <label>Степень IDW</label>
            <input type="number" step="0.1" className="border rounded p-1" value={idwPower} onChange={(e)=>setIdwPower(Number(e.target.value))} />
          </div>
          <p className="text-xs text-slate-500">Больше cols/rows → детальнее, но медленнее. IDW=2 — стандартно.</p>
        </section>

        <section className="space-y-2">
          <h2 className="font-semibold">Горизонтали</h2>
          <div className="grid grid-cols-2 gap-2 items-center text-sm">
            <label>Шаг (м)</label>
            <input type="number" step="0.1" className="border rounded p-1" value={contourStep} onChange={(e)=>setContourStep(Number(e.target.value))} />
            <label>Основная через</label>
            <input type="number" className="border rounded p-1" value={majorEvery} onChange={(e)=>setMajorEvery(Number(e.target.value))} />
          </div>
          <div className="flex gap-2">
            <button className="px-3 py-2 rounded bg-blue-600 text-white hover:bg-blue-700" onClick={downloadSVG}>Скачать SVG</button>
          </div>
          <p className="text-xs text-slate-500">Основная — более толстая линия (каждая N-я). Метки высот — рядом с линией.</p>
        </section>

        <section className="space-y-1 text-xs text-slate-500">
          <p>Добавление точки: клик по полю, введите высоту.</p>
          <p>CSV сохраняется вместе с точками — можно копировать/вставлять.</p>
        </section>
      </div>

      {/* Drawing */}
      <div className="flex-1 p-4 overflow-auto">
        <div className="rounded-2xl bg-white shadow-sm border border-slate-200 p-2">
          <svg
            ref={svgRef}
            width={width}
            height={height}
            viewBox={`0 0 ${width} ${height}`}
            className="w-full h-auto cursor-crosshair"
            onClick={onSvgClick}
          >
            <defs>
              <pattern id="grid-pattern" width="10" height="10" patternUnits="userSpaceOnUse">
                <path d="M 10 0 L 0 0 0 10" fill="none" stroke="#eee" strokeWidth="1" />
              </pattern>
            </defs>

            {/* Background */}
            <rect x={0} y={0} width={width} height={height} fill="#fafafa" />

            {/* Plot area border */}
            <rect x={pad} y={pad} width={width - 2*pad} height={height - 2*pad} fill="#fff" stroke="#e5e7eb" />

            {/* Grid lines in domain units */}
            {showGrid && (
              <g>
                {/* Vertical lines */}
                {gridLines.xs.map((xv) => {
                  const sx = X(xv);
                  return <line key={`gx-${xv}`} x1={sx} x2={sx} y1={pad} y2={height - pad} stroke="#f1f5f9" />
                })}
                {/* Horizontal lines */}
                {gridLines.ys.map((yv) => {
                  const sy = invertY ? Ybase(yv) : Yinv(yv);
                  return <line key={`gy-${yv}`} x1={pad} x2={width - pad} y1={sy} y2={sy} stroke="#f1f5f9" />
                })}
                {/* Axis labels */}
                {gridLines.xs.map((xv) => (
                  <text key={`gxl-${xv}`} x={X(xv)} y={height - pad + 16} fontSize={10} textAnchor="middle" fill="#475569">{formatNum(xv)}</text>
                ))}
                {gridLines.ys.map((yv) => (
                  <text key={`gyl-${yv}`} x={pad - 6} y={(invertY ? Ybase(yv) : Yinv(yv)) + 3} fontSize={10} textAnchor="end" fill="#475569">{formatNum(yv)}</text>
                ))}
              </g>
            )}

            {/* Contours */}
            <g>
              {d3c.map((cont, idx) => {
                const isMajor = majorLevels.has(cont.value);
                const stroke = isMajor ? "#334155" : "#64748b";
                const sw = isMajor ? 1.6 : 0.9;
                return (
                  <g key={`c-${idx}`}>
                    {cont.coordinates.map((poly, pi) => (
                      <path
                        key={`c-${idx}-${pi}`}
                        d={poly.map((ring) => ringToPath(ring, gridToDomain, toScreen)).join(" ")}
                        fill="none"
                        stroke={stroke}
                        strokeWidth={sw}
                      />
                    ))}
                    {/* label near the first ring's middle point */}
                    {cont.coordinates[0] && cont.coordinates[0][0] && (() => {
                      const ring = cont.coordinates[0][0];
                      const mid = ring[Math.floor(ring.length / 2)];
                      const { x, y } = gridToDomain(mid[0], mid[1]);
                      const { X: sx, Y: sy } = toScreen(x, y);
                      return (
                        <g key={`cl-${idx}`}>
                          <rect x={sx - 12} y={sy - 8} width={24} height={14} rx={3} ry={3} fill="#ffffffcc" />
                          <text x={sx} y={sy + 2} fontSize={10} textAnchor="middle" fill="#0f172a">{formatNum(cont.value)}</text>
                        </g>
                      );
                    })()}
                  </g>
                );
              })}
            </g>

            {/* Points */}
            {showPoints && (
              <g>
                {pts.map((p, i) => {
                  const { X: sx, Y: sy } = toScreen(p.x, p.y);
                  return (
                    <g key={`pt-${i}`}>
                      <circle cx={sx} cy={sy} r={3.5} fill="#0ea5e9" stroke="#0369a1" />
                      {showLabels && (
                        <text x={sx + 6} y={sy - 6} fontSize={11} fill="#0f172a">{p.id ?? `P${i+1}`} <tspan fill="#475569">({formatNum(p.x)}, {formatNum(p.y)})</tspan> <tspan fontWeight={600}>{formatNum(p.z)}</tspan></text>
                      )}
                    </g>
                  );
                })}
              </g>
            )}

            {/* Axes titles */}
            <text x={width/2} y={height - 10} textAnchor="middle" fontSize={12} fill="#475569">X</text>
            <text x={14} y={height/2} textAnchor="middle" fontSize={12} fill="#475569" transform={`rotate(-90 14 ${height/2})`}>Y</text>

          </svg>
        </div>

        {/* Stats footer */}
        <div className="mt-3 text-xs text-slate-500 flex flex-wrap gap-4">
          <span>Точек: <b>{pts.length}</b></span>
          <span>Диапазон X: <b>{formatNum(domain.minX)}</b> … <b>{formatNum(domain.maxX)}</b></span>
          <span>Диапазон Y: <b>{formatNum(domain.minY)}</b> … <b>{formatNum(domain.maxY)}</b></span>
          <span>Высоты: <b>{formatNum(zstats.minZ)}</b> … <b>{formatNum(zstats.maxZ)}</b></span>
          <span>Горизонталей: <b>{thresholds.length}</b></span>
        </div>
      </div>
    </div>
  );
}
